-175. Combining two tables
SELECT a.firstName, a.lastName, b.city, b.state 
FROM Person AS a LEFT JOIN Address AS b ON a.personId = b.personId

-181. Employees Earning More Than Their Managers
SELECT Employee
FROM (SELECT a.name AS Employee, a.salary AS Employee_salary, b.salary AS manager_salary FROM Employee AS a JOIN Employee as b ON a.managerId = b.id)
AS sub WHERE Employee_salary > manager_salary
#USING SELF JOIN AND SUBQUERY. 
#CAUTION: Have to have alias in SELF JOIN, SUBQUERY


-182. Duplicate Emails
SELECT Email FROM(SELECT email, COUNT(*) AS COUNTING FROM Person GROUP BY email) AS sub WHERE COUNTING > 1 #my answer
SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1 #Other one


-183. Customers Who Never Order
SELECT name AS Customers FROM (SELECT a.id, a.name, b.customerId FROM Customers as a LEFT JOIN Orders AS b ON a.id = b.customerId WHERE b.customerId IS NULL) AS sub #my answer
select Name as Customers from Customers where Id not in (select CustomerId from Orders) #Other one. USING not in


-196. Delete Duplicate Emails(USING DELETE statement)
DELETE FROM PERSON WHERE ID NOT IN (SELECT MIN(ID) FROM PERSON GROUP BY EMAIL) #SQL Ver.
Person.drop(Person[Person.duplicated('email', keep='first')].index, inplace=True) #Pandas Ver.


-197. Rising Temperature
SELECT ID FROM (SELECT ID, TEMPERATURE, LAG(TEMPERATURE)  OVER (ORDER BY ID) AS PREV_TEMPERATURE FROM WEATHER) AS SUB #SQL Ver.
WHERE TEMPERATURE > PREV_TEMPERATURE #If there is not alias, will be error

def rising_temperature(weather: pd.DataFrame) -> pd.DataFrame: #Pandas Ver.
    copy_shift = weather.shift()
    weather['match'] = weather.temperature > copy_shift.temperature
    return weather.loc[weather['match'] == True, ['id']] # without [ ] at ['id'], return class series.


-511. Game Play Analysis I
SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID #SQL Ver.

a = activity.groupby('player_id', as_index=False)['event_date'].min() #Pandas Ver. / Using 'groupby' function is point. parameter 'as_index' makes return type to DataFrame 
     a.rename(columns = {'event_date': 'first_login'}, inplace = True)
     return a 

-577. Employee Bonus
SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E  #SQL Ver.
LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID
WHERE B.BONUS < 1000 OR B.BONUS IS NULL 

m = pd.merge(left = employee, right = bonus, how= 'left', on = 'empId') #Pandas Ver.
    return m[(m['bonus']<2000)|(m['bonus'].isna())][['name','bonus']]

-584. Find Customer Referee
SELECT name FROM CUSTOMER WHERE REFEREE_ID != 2 OR REFEREE_ID IS NULL #SQL Ver.

return customer[(customer['referee_id']!= 2)|(customer['referee_id'].isna())][['name']] #Pandas Ver.

-586. Customer Placing the Largest Number of Orders
SELECT CUSTOMER_NUMBER FROM ORDERS GROUP BY CUSTOMER_NUMBER #SQL Ver.
HAVING COUNT(*) = (SELECT MAX(SUB) 
FROM (SELECT COUNT(*) AS SUB FROM ORDERS GROUP BY CUSTOMER_NUMBER) AS A) # Can't use alias in Having sentence. so use COUNT(*) again.

a=orders.groupby('customer_number', as_index=False).count()
     return  a.loc[a['order_number']==a['order_number'].max(), ['customer_number']] #Pandas Ver.

-595. Big Countries
SELECT name, population, area FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000 #SQL Ver.

return world.loc[(world['area']>=3000000)|(world['population']>25000000), ['name', 'population', 'area']] #Pandas Ver.
                                                                                                          #Include parentheses

-596. Classes With at Least 5 Students
SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5 #SQL Ver.

grouped = courses.groupby(['class'], as_index=False).count() #Pandas Ver.
                                                             #Using count()
    return grouped.loc[grouped['student']>=5, ['class']]

-607. Sales Person
WITH CTE(COM_ID, SALES_ID, COM_NAME) AS            #SQL Ver.
(
    SELECT O.COM_ID, O.SALES_ID, C.NAME FROM COMPANY AS C 
    INNER JOIN ORDERS AS O ON C.COM_ID = O.COM_ID WHERE O.COM_ID = 1
)

SELECT NAME FROM SALESPERSON WHERE SALES_ID NOT IN (SELECT SALES_ID FROM CTE)

 j=pd.merge(company, orders, "inner", 'com_id')    #Pandas Ver.
     j=j.loc[j['com_id']==1, ['com_id', 'sales_id']]
     J=pd.merge(sales_person, j, "left", 'sales_id')
     return J.loc[J['com_id'].isna(), ['name']]


-610. Triangle Judgement (7/27)
SELECT  *,     #SQL Ver.
CASE WHEN X+Y > Z AND X+Z > Y AND Y+Z > X THEN 'Yes'
		ELSE 'No'
	END AS 'TRIANGLE'
FROM TRIANGLE    #Using Case method

a=triangle    #Pandas Ver.
    cond = (a['x']+a['y']>a['z'])&(a['x']+a['z']>a['y'])&(a['y']+a['z']>a['x'])
    for i in range(0,2):
        if cond[i]:
            a.loc[i, 'triangle']='Yes'  
        else:
            a.loc[i, 'triangle']='No'
    return a

-619. Biggest Single Number (7/28)
SELECT MAX(NUM) FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*)=1) AS SUB #SQL Ver.

max_unique = my_numbers.drop_duplicates(keep=False)['num'].max()	#Pandas Ver.
    if pd.isna(max_unique):
        result=pd.DataFrame({'num':[np.nan]})
    else:
        result=my_numbers.loc[my_numbers['num']==max_unique, ['num']]
        if result.empty:
            result = pd.DataFrame({'num':[np.nan]})
    return result

-620. Not Boring Movies (7/28)
SELECT * FROM CINEMA WHERE ID%2 != 0 AND DESCRIPTION != 'BORING' ORDER BY RATING DESC	#SQL Ver.

a=cinema.loc[(cinema['id']%2 == 1) & (cinema['description'] != 'boring'), ['id', 'movie', 'description', 'rating']]
    return a.sort_values(by = 'rating', ascending=False, inplace = False)	#Pandas Ver.

-627. Swap Salary (7/29)
UPDATE SALARY #SQL Ver.
SET sex = CASE
WHEN sex = 'f' THEN 'm'
WHEN sex = 'm' THEN 'f'
ELSE sex END 

salary['sex']=salary['sex'].apply(lambda x:'f' if x=='m' else 'm')	#Pandas Ver. 
    return salary

-1050. Actors and Directors Who Cooperated At Least Three Times(8/1)
SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(*) >=3 #SQL Ver.

a=actor_director.groupby(['actor_id', 'director_id']).size()	#Pandas Ver.
    return a[a>=3].reset_index()[['actor_id', 'director_id']]

-1068. Product Sales Analysis I(8/2)
SELECT B.PRODUCT_NAME, A.YEAR, A.PRICE FROM SALES AS A  #SQL Ver.
INNER JOIN PRODUCT AS B ON A.PRODUCT_ID = B.PRODUCT_ID

a=sales.merge(product, "inner", 'product_id')	#Pandas Ver
    return a[['product_name', 'year', 'price']] 

-1075. Project Employees I (8/2)
SELECT A.PROJECT_ID, CAST(AVG(CAST(B.EXPERIENCE_YEARS AS FLOAT)) AS DECIMAL(10, 2)) AS AVERAGE_YEARS FROM PROJECT AS A 
INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID
GROUP BY A.PROJECT_ID	#SQL Ver.

a=project.merge(employee, "inner", 'employee_id')	#Pandas Ver.
     a[['project_id', 'experience_years']]
     grouped = a.groupby('project_id', as_index=False)['experience_years'].mean()
     grouped = grouped.rename(columns={'experience_years': 'average_years'})
     return grouped

-1084. Sales Analysis III (8/5)
SELECT A.PRODUCT_ID, A.PRODUCT_NAME FROM PRODUCT AS A	#SQL Ver.
INNER JOIN SALES AS B ON A.PRODUCT_ID = B.PRODUCT_ID
WHERE A.PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES
GROUP BY PRODUCT_ID HAVING COUNT(*)=1)
AND (B.SALE_DATE >= '2019-01-01' AND B.SALE_DATE <= '2019-03-01')

m = product.merge(sales, "inner", 'product_id')	#Pandas Ver.
g = m.drop_duplicates(['product_id'], keep = False, inplace = True)
return m.loc[(m['sale_date']>= '2019-01-01')&(m['sale_date']<='2019-03-01'), ['product_id', 'product_name']] 

-1141. User Activity for the Past 30 Days I (8/5)
SELECT SUB.ACTIVITY_DATE AS DAY, COUNT(*) AS ACTIVE_USERS	#SQL Ver.
FROM(
SELECT USER_ID, ACTIVITY_DATE FROM ACTIVITY
GROUP BY USER_ID, ACTIVITY_DATE HAVING ACTIVITY_DATE >= '2019-06-27') AS SUB
GROUP BY SUB.ACTIVITY_DATE

g = activity.groupby(['user_id','activity_date']).size()	#Pandas Ver.
    g.reset_index()[['user_id', 'activity_date']]
    g1 = g.groupby('activity_date').size()
    a=pd.DataFrame({'day':g1.index, 'active_users':g1.values})
    return a.loc[a['day']>='2019-06-27', ['day', 'active_users']]
